{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[126],{1103:function(a,_,t){\"use strict\";t.r(_);var e=t(42),v=Object(e.a)({},(function(){var a=this,_=a.$createElement,e=a._self._c||_;return e(\"ContentSlotsDistributor\",{attrs:{\"slot-key\":a.$parent.slotKey}},[e(\"h1\",{attrs:{id:\"联合索引\"}},[e(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#联合索引\"}},[a._v(\"#\")]),a._v(\" 联合索引\")]),a._v(\" \"),e(\"h2\",{attrs:{id:\"_1-什么是联合索引\"}},[e(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_1-什么是联合索引\"}},[a._v(\"#\")]),a._v(\" 1. 什么是联合索引\")]),a._v(\" \"),e(\"p\",[a._v(\"两个或更多个列上的索引被称为联合索引，联合索引又叫复合索引。\")]),a._v(\" \"),e(\"p\",[a._v(\"对于联合索引：\")]),a._v(\" \"),e(\"ul\",[e(\"li\",[a._v(\"MySql从左到右使用索引中字段\")]),a._v(\" \"),e(\"li\",[a._v(\"一个查询可以只使用索引中的一部分，但只能是最左部分（最左前缀）\")])]),a._v(\" \"),e(\"p\",[a._v(\"例如：\")]),a._v(\" \"),e(\"p\",[a._v(\"索引是key index（a,b,c） 可以支持\"),e(\"strong\",[a._v(\"a|a,b|a,b,c\")]),a._v(\"，三种组合查找，但不支持b,c 进行查找。当最左侧字段是常量引用时，索引就十分有效\")]),a._v(\" \"),e(\"h2\",{attrs:{id:\"_2-需要遵循的规则\"}},[e(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_2-需要遵循的规则\"}},[a._v(\"#\")]),a._v(\" 2. 需要遵循的规则\")]),a._v(\" \"),e(\"ol\",[e(\"li\",[a._v(\"需要加索引的字段，要在where条件中\")]),a._v(\" \"),e(\"li\",[a._v(\"数据量少的字段不需要加索引\")]),a._v(\" \"),e(\"li\",[a._v(\"如何where条件中是or关系，加索引不起作用\")]),a._v(\" \"),e(\"li\",[a._v(\"符合最左前缀原则\")])]),a._v(\" \"),e(\"h2\",{attrs:{id:\"_3-原理\"}},[e(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_3-原理\"}},[a._v(\"#\")]),a._v(\" 3. 原理\")]),a._v(\" \"),e(\"h3\",{attrs:{id:\"_3-1-b-tree结构\"}},[e(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_3-1-b-tree结构\"}},[a._v(\"#\")]),a._v(\" 3.1 B+Tree结构\")]),a._v(\" \"),e(\"p\",[a._v(\"每一个磁盘快在mysql中是一个页，页大小是固定的，mysql innodb的默认的页大小是16k。每个索引会分配在页上的数量是由字段的大小决定。当字段值长度越长，每一页上的数量就会越少，因此在一定数据量的情况下，所以的深度会越深，影响索引查找效率\")]),a._v(\" \"),e(\"p\",[e(\"img\",{attrs:{src:t(528),alt:\"image-20190909223519018\"}})]),a._v(\" \"),e(\"p\",[a._v(\"对于复合索引（多列b+tree,使用多列值组合而成的b+tree索引）。遵循最左前缀原则，从左到右的使用索引中的字段，\"),e(\"strong\",[a._v(\"一个查询可以只使用索引中的一部分，但只能是做左侧部分\")])]),a._v(\" \"),e(\"h3\",{attrs:{id:\"_3-2-实例\"}},[e(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_3-2-实例\"}},[a._v(\"#\")]),a._v(\" 3.2 实例\")]),a._v(\" \"),e(\"p\",[a._v(\"创建表test\")]),a._v(\" \"),e(\"div\",{staticClass:\"language- extra-class\"},[e(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[e(\"code\",[a._v(\"create table test(\\n\\na int,\\n\\nb int,\\n\\nc int,\\n\\nKEY a(a,b,c)\\n\\n);\\n\")])])]),e(\"p\",[a._v(\"比如（a,b,c）的时候，b+tree是按照从\"),e(\"strong\",[a._v(\"左到右的顺序来建立搜索树\")]),a._v(\"的\")]),a._v(\" \"),e(\"ul\",[e(\"li\",[a._v(\"当（a =? and b= ? and c=?) 这样的数据来检索的时候\\n\"),e(\"ul\",[e(\"li\",[a._v(\"b+树会优先比较a列来确定下一步的方向\")]),a._v(\" \"),e(\"li\",[a._v(\"如果a列相同再依次比较b列和c列\")]),a._v(\" \"),e(\"li\",[a._v(\"最后得到检索数据\")])])]),a._v(\" \"),e(\"li\",[a._v(\"但当（b=? and c =?）这样没有a列的数据来的时候\\n\"),e(\"ul\",[e(\"li\",[a._v(\"b+树就不知道下一步该查那个节点，因为建立搜索树的时候a列就是第一个比较因子。必须要先跟a列来搜索才能知道下一步去哪里查询\")])])]),a._v(\" \"),e(\"li\",[a._v(\"当（a=? and c =?）这样的数据来检索时\\n\"),e(\"ul\",[e(\"li\",[a._v(\"b+树可以用a列来制定搜索方向，但下一个字段b列的缺失，只能吧a列的数据找到\")]),a._v(\" \"),e(\"li\",[a._v(\"然后在匹配c列的数据\")])])])]),a._v(\" \"),e(\"h2\",{attrs:{id:\"_4-多列索引的应用\"}},[e(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_4-多列索引的应用\"}},[a._v(\"#\")]),a._v(\" 4. 多列索引的应用\")]),a._v(\" \"),e(\"h3\",{attrs:{id:\"_4-1-多列索引在and查询中的应用\"}},[e(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_4-1-多列索引在and查询中的应用\"}},[a._v(\"#\")]),a._v(\" 4.1 多列索引在and查询中的应用\")]),a._v(\" \"),e(\"ul\",[e(\"li\",[e(\"p\",[a._v(\"select * from test where a=? and b=? and c=?；\")]),a._v(\" \"),e(\"p\",[a._v(\"查询效率最高，索引全覆盖。\")])]),a._v(\" \"),e(\"li\",[e(\"p\",[a._v(\"select * from test where a=? and b=?\")]),a._v(\" \"),e(\"p\",[a._v(\"索引覆盖a和b。\")])]),a._v(\" \"),e(\"li\",[e(\"p\",[a._v(\"select * from test where b=? and a=?\")]),a._v(\" \"),e(\"p\",[a._v(\"经过mysql的查\"),e(\"strong\",[a._v(\"询分析器的优化，索引覆盖a和b\")]),a._v(\"。\")])]),a._v(\" \"),e(\"li\",[e(\"p\",[a._v(\"select * from test where a=?；\")]),a._v(\" \"),e(\"p\",[a._v(\"索引覆盖a。\")])]),a._v(\" \"),e(\"li\",[e(\"p\",[a._v(\"select * from test where b=? and c=?\")]),a._v(\" \"),e(\"p\",[a._v(\"没有a列，不走索引，索引失效。\")])]),a._v(\" \"),e(\"li\",[e(\"p\",[a._v(\"select * from test where c=?；\")]),a._v(\" \"),e(\"p\",[a._v(\"没有a列，不走索引，索引失效。\")])])]),a._v(\" \"),e(\"h3\",{attrs:{id:\"_4-2-多列索引在范围查询中应用\"}},[e(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_4-2-多列索引在范围查询中应用\"}},[a._v(\"#\")]),a._v(\" 4.2 多列索引在范围查询中应用\")]),a._v(\" \"),e(\"ul\",[e(\"li\",[e(\"p\",[a._v(\"select * from test where a=? and b between ? and ? and c=?；\")]),a._v(\" \"),e(\"p\",[a._v(\"索引覆盖a和b，\"),e(\"strong\",[a._v(\"因b列是范围查询，因此c列不能走索引\")]),a._v(\"。\")])]),a._v(\" \"),e(\"li\",[e(\"p\",[a._v(\"select * from test where a between ? and ? and b=?；\")]),a._v(\" \"),e(\"p\",[a._v(\"a列走索引，因a列是范围查询，因此b列是无法使用索引。\")])]),a._v(\" \"),e(\"li\",[e(\"p\",[a._v(\"select * from test where a between ? and ? and b between ? and ? and c=?；\")]),a._v(\" \"),e(\"p\",[a._v(\"a列走索引，因a列是范围查询，b列是范围查询也不能使用索引。\")])])]),a._v(\" \"),e(\"h3\",{attrs:{id:\"_4-3-多列索引在排序中应用\"}},[e(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_4-3-多列索引在排序中应用\"}},[a._v(\"#\")]),a._v(\" 4.3 \"),e(\"strong\",[a._v(\"多列索引在排序中应用\")])]),a._v(\" \"),e(\"ul\",[e(\"li\",[e(\"p\",[a._v(\"select * from test where a=? and b=? order by c；\")]),a._v(\" \"),e(\"p\",[a._v(\"a、b、c三列全覆盖索引，查询效率最高。\")])]),a._v(\" \"),e(\"li\",[e(\"p\",[a._v(\"select * from test where a=? and b between ? and ? order by c；\")]),a._v(\" \"),e(\"p\",[a._v(\"a、b列使用索引查找，因b列是范围查询，因此c列不能使用索引，会出现file sort。\")])])]),a._v(\" \"),e(\"h2\",{attrs:{id:\"_5-总结\"}},[e(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_5-总结\"}},[a._v(\"#\")]),a._v(\" 5. 总结\")]),a._v(\" \"),e(\"ul\",[e(\"li\",[e(\"p\",[a._v(\"联合索引的使用在写where调的顺序无关，mysql 查询分析会进行优化而使用索引，但是为了减轻查询分析器的压力，最好和索引的从左到右的顺序一致\")])]),a._v(\" \"),e(\"li\",[e(\"p\",[a._v(\"使用等值查询，多列同时查询，索引会一直传递并生效。因此等值查询效率最好。\")])]),a._v(\" \"),e(\"li\",[e(\"p\",[a._v(\"索引查找遵循最左侧原则。\"),e(\"strong\",[a._v(\"但是遇到范围查询列之后的列索引失效。\")])])]),a._v(\" \"),e(\"li\",[e(\"p\",[a._v(\"排序也能使用索引，合理使用索引排序，避免出现file sort。\")])])])])}),[],!1,null,null,null);_.default=v.exports},528:function(a,_,t){a.exports=t.p+\"assets/img/image-20190909223519018.bf936230.png\"}}]);","extractedComments":[]}