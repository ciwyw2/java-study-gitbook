{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[198],{983:function(a,e,t){\"use strict\";t.r(e);var n=t(42),v=Object(n.a)({},(function(){var a=this,e=a.$createElement,t=a._self._c||e;return t(\"ContentSlotsDistributor\",{attrs:{\"slot-key\":a.$parent.slotKey}},[t(\"h1\",{attrs:{id:\"cas-比较并替换\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#cas-比较并替换\"}},[a._v(\"#\")]),a._v(\" CAS（比较并替换）\")]),a._v(\" \"),t(\"h2\",{attrs:{id:\"_1-简介\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_1-简介\"}},[a._v(\"#\")]),a._v(\" 1. 简介\")]),a._v(\" \"),t(\"p\",[a._v(\"CAS（compare and Swap），既比较并替换，实现并发算法时常用到的一种技术\")]),a._v(\" \"),t(\"blockquote\",[t(\"p\",[a._v(\"在java同步器中大量使用了CAS技术，鬼斧神工的实现了多线程执行的安全性\")])]),a._v(\" \"),t(\"p\",[a._v(\"CAS的思想很简单: 三个参数，一个当前内存值V、旧的预期值A、即将更新的值B、\"),t(\"strong\",[a._v(\"当且仅当\"),t(\"code\",[a._v(\"预期值A\")]),a._v(\"和\"),t(\"code\",[a._v(\"内存值V\")]),a._v(\"相同时\")]),a._v(\"，将内存值修改为B并返回true，否则什么都不做，并返回false\")]),a._v(\" \"),t(\"h2\",{attrs:{id:\"_2-问题\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_2-问题\"}},[a._v(\"#\")]),a._v(\" 2. 问题\")]),a._v(\" \"),t(\"p\",[a._v(\"一个\"),t(\"code\",[a._v(\"n++\")]),a._v(\"的问题\")]),a._v(\" \"),t(\"div\",{staticClass:\"language- extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[a._v(\"public class Case {\\n\\n    public volatile int n;\\n\\n    public void add() {\\n        n++;\\n    }\\n}\\n\")])])]),t(\"p\",[a._v(\"通过\"),t(\"code\",[a._v(\"javac Case.java\")]),a._v(\" 将java文件先编译成class\")]),a._v(\" \"),t(\"p\",[a._v(\"再通过\"),t(\"code\",[a._v(\"javap -verbose Case\")]),a._v(\"看看add方法的字节码指令\")]),a._v(\" \"),t(\"div\",{staticClass:\"language- extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[a._v('public void add();\\n    descriptor: ()V\\n    flags: ACC_PUBLIC\\n    Code:\\n      stack=3, locals=1, args_size=1\\n         0: aload_0\\n         1: dup\\n         2: getfield      #2                  // Field n:I\\n         5: iconst_1\\n         6: iadd\\n         7: putfield      #2                  // Field n:I\\n        10: return\\n      LineNumberTable:\\n        line 12: 0\\n        line 13: 10\\n}\\nSourceFile: \"Case.java\"\\n')])])]),t(\"p\",[a._v(\"n++ 被拆分成了几个指令\")]),a._v(\" \"),t(\"ol\",[t(\"li\",[a._v(\"执行\"),t(\"code\",[a._v(\"getfield\")]),a._v(\"拿到原始n；\")]),a._v(\" \"),t(\"li\",[a._v(\"执行\"),t(\"code\",[a._v(\"iadd\")]),a._v(\"进行加1操作\")]),a._v(\" \"),t(\"li\",[a._v(\"执行\"),t(\"code\",[a._v(\"putfield\")]),a._v(\"写把累加后的值写回n；\")])]),a._v(\" \"),t(\"p\",[a._v(\"通过volatile修饰的变量可以保证线程之间的可见性，但并不能保证这3个指令的原子执行，在多线程并发执行下，无法做到线程安全，得到正确的结果，那么如何解决呢？\")]),a._v(\" \"),t(\"h2\",{attrs:{id:\"_3-如何解决\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_3-如何解决\"}},[a._v(\"#\")]),a._v(\" 3. 如何解决\")]),a._v(\" \"),t(\"h3\",{attrs:{id:\"_3-1-方案1-在add-方法加上synchrnized修饰\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_3-1-方案1-在add-方法加上synchrnized修饰\"}},[a._v(\"#\")]),a._v(\" 3.1 方案1：在add 方法加上synchrnized修饰\")]),a._v(\" \"),t(\"div\",{staticClass:\"language- extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[a._v(\"public class Case {\\n\\n    public volatile int n;\\n\\n    public synchronized void add() {\\n        n++;\\n    }\\n}\\n\")])])]),t(\"p\",[a._v(\"这个方案当然可行，但是性能上差了点\")]),a._v(\" \"),t(\"p\",[a._v(\"我们再来看一段代码\")]),a._v(\" \"),t(\"div\",{staticClass:\"language- extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[a._v(\"public int a = 1;\\npublic boolean compareAndSwapInt(int b) {\\n    if (a == 1) {\\n        a = b;\\n        return true;\\n    }\\n    return false;\\n}\\n\")])])]),t(\"p\",[a._v(\"如果这段代码在并发下执行，会发生什么？\")]),a._v(\" \"),t(\"p\",[a._v(\"假设线程1和线程2 都过了\"),t(\"code\",[a._v(\"a==1\")]),a._v(\"的检查。都准备执行a进行赋值，结果就是两个线程同时修改了变量a。显然这种结果是无法符合预期的，无法确定a的最终值。\")]),a._v(\" \"),t(\"p\",[a._v(\"解决方案也同样暴力在compareAndSwapInt方法加锁同步，变成一个原子操作，同一时刻只有一个线程才能修改变量a。\")]),a._v(\" \"),t(\"h3\",{attrs:{id:\"_3-2-方案2-cas方案\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_3-2-方案2-cas方案\"}},[a._v(\"#\")]),a._v(\" 3.2 方案2：CAS方案\")]),a._v(\" \"),t(\"p\",[a._v(\"除了地行政的加锁方案，我们还可以使用JDK自带的CAS方案，在CAS中，比较和替换是一组原子操作，不会被外部打断，且在性能上更占优势\")]),a._v(\" \"),t(\"p\",[a._v(\"下面是\"),t(\"code\",[a._v(\"AtomicInteger\")]),a._v(\"的实现为例，分析一下CAS是如何实现的\")]),a._v(\" \"),t(\"div\",{staticClass:\"language- extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[a._v('public class AtomicInteger extends Number implements java.io.Serializable {\\n    // setup to use Unsafe.compareAndSwapInt for updates\\n    private static final Unsafe unsafe = Unsafe.getUnsafe();\\n    private static final long valueOffset;\\n\\n    static {\\n        try {\\n            valueOffset = unsafe.objectFieldOffset\\n                (AtomicInteger.class.getDeclaredField(\"value\"));\\n        } catch (Exception ex) { throw new Error(ex); }\\n    }\\n\\n    private volatile int value;\\n    public final int get() {return value;}\\n}\\n')])])]),t(\"ol\",[t(\"li\",[a._v(\"Unsafe,是CAS的核心类，由于Java方法无法直接访问底层系统，需要通过本地（native）方法来访问，Unsafe相当于一个后门，基于该类可以直接操作特定内存数据\")]),a._v(\" \"),t(\"li\",[a._v(\"变量valueOffset，表示该变量值在内存中的偏移地址，因为Unsafe就是根据内存偏移地址获取数据的\")]),a._v(\" \"),t(\"li\",[a._v(\"变量value和volatile修饰，保证了多线程之间内存的可见性\")])]),a._v(\" \"),t(\"p\",[a._v(\"看看\"),t(\"code\",[a._v(\"AtomicInteger\")]),a._v(\"如何实现并发下的累加操作：\")]),a._v(\" \"),t(\"div\",{staticClass:\"language- extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[a._v(\"public final int getAndAdd(int delta) {    \\n    return unsafe.getAndAddInt(this, valueOffset, delta);\\n}\\n\\n//unsafe.getAndAddInt\\npublic final int getAndAddInt(Object var1, long var2, int var4) {\\n    int var5;\\n    do {\\n        var5 = this.getIntVolatile(var1, var2);\\n    } while(!this.compareAndSwapInt(var1, var2, var5, var5 + var4));\\n    return var5;\\n}\\n\")])])]),t(\"p\",[a._v(\"假设线程A和线程B同时执行getAndAdd操作（分别跑在不同的CPU上）\")]),a._v(\" \"),t(\"ol\",[t(\"li\",[t(\"p\",[a._v(\"AtomicInteger里面的value原始值为3，既\"),t(\"strong\",[a._v(\"主内存中AtomicInteger的value为3\")]),a._v(\"，根据java内存模型，\"),t(\"strong\",[a._v(\"线程A和线程B各自持有一份value的副本，值为3\")])])]),a._v(\" \"),t(\"li\",[t(\"p\",[a._v(\"线程A通过\"),t(\"code\",[a._v(\"getIntVolatile(var1, var2)\")]),a._v(\"拿到value值3，这时线程A被挂起。\")])]),a._v(\" \"),t(\"li\",[t(\"p\",[a._v(\"线程B也通过\"),t(\"code\",[a._v(\"getIntVolatile(var1, var2)\")]),a._v(\"方法获取到value值3，运气好，线程B没有被挂起，并执行\"),t(\"code\",[a._v(\"compareAndSwapInt\")]),a._v(\"方法比较内存值也为3，成功修改内存值为2。\")])]),a._v(\" \"),t(\"li\",[t(\"p\",[a._v(\"这时线程A恢复，执行\"),t(\"code\",[a._v(\"compareAndSwapInt\")]),a._v(\"方法比较，发现自己手里的值(3)和内存的值(2)不一致，说明该值已经被其它线程提前修改过了，那只能重新来一遍了。\")])]),a._v(\" \"),t(\"li\",[t(\"p\",[a._v(\"重新获取value值，因为变量value被volatile修饰，所以其它线程对它的修改，线程A总是能够看到，线程A继续执行\"),t(\"code\",[a._v(\"compareAndSwapInt\")]),a._v(\"进行比较替换，直到成功\")])])]),a._v(\" \"),t(\"p\",[a._v(\"整个过程中，利用CAS保证了对于value的修改的并发安全，继续深入看看Unsafe类中的compareAndSwapInt方法实现。\")]),a._v(\" \"),t(\"div\",{staticClass:\"language- extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[a._v(\"public final native boolean compareAndSwapInt(Object paramObject, lo\\n\")])])]),t(\"p\",[a._v(\"Unsafe类中的compareAndSwapInt，是一个本地方法，该方法的实现位于\"),t(\"code\",[a._v(\"unsafe.cpp\")]),a._v(\"中\")]),a._v(\" \"),t(\"div\",{staticClass:\"language- extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[a._v('UNSAFE_ENTRY(jboolean, Unsafe_CompareAndSwapInt(JNIEnv *env, jobject unsafe, jobject obj, jlong offset, jint e, jint x))\\n  UnsafeWrapper(\"Unsafe_CompareAndSwapInt\");\\n  oop p = JNIHandles::resolve(obj);\\n  jint* addr = (jint *) index_oop_from_field_offset_long(p, offset);\\n  return (jint)(Atomic::cmpxchg(x, addr, e)) == e;\\nUNSAFE_END\\n')])])]),t(\"ol\",[t(\"li\",[a._v(\"先想办法拿到变量value在内存中的地址\")]),a._v(\" \"),t(\"li\",[a._v(\"通过Atomic::cmpxchg实现替换，其中参数x是即将更新的值，参数e是原内存的值\")])]),a._v(\" \"),t(\"h2\",{attrs:{id:\"_4-cas缺点\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_4-cas缺点\"}},[a._v(\"#\")]),a._v(\" 4. CAS缺点\")]),a._v(\" \"),t(\"p\",[a._v(\"CAS存在一个很明显的问题，既ABA问题\")]),a._v(\" \"),t(\"p\",[a._v(\"问题：如果变量V初次读取的时候是A，并且在准备赋值的时候检查到他的仍然是A，那能说明他的值没有被其他线程修改了吗？\")]),a._v(\" \"),t(\"p\",[a._v(\"如果在这段期间层级被改成B,然后又改回A，那么CAS操作就会误认为他从来没有被修改过。针对这种情况，java并发包中提供了一个带有标记的原子引用类\"),t(\"code\",[a._v(\"AtomicStampedReference\")]),a._v(\",它可以\"),t(\"strong\",[a._v(\"通过控制变量值的版本来保证CAS的正确性\")])]),a._v(\" \"),t(\"h3\",{attrs:{id:\"参考文章\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#参考文章\"}},[a._v(\"#\")]),a._v(\" 参考文章\")]),a._v(\" \"),t(\"p\",[t(\"a\",{attrs:{href:\"https://www.jianshu.com/p/fb6e91b013cc\",target:\"_blank\",rel:\"noopener noreferrer\"}},[a._v(\"深入浅出CAS\"),t(\"OutboundLink\")],1)])])}),[],!1,null,null,null);e.default=v.exports}}]);","extractedComments":[]}