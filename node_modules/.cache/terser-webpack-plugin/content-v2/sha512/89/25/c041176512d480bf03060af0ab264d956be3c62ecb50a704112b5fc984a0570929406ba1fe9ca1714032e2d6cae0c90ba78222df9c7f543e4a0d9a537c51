{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[130],{1124:function(_,v,t){\"use strict\";t.r(v);var r=t(42),s=Object(r.a)({},(function(){var _=this,v=_.$createElement,r=_._self._c||v;return r(\"ContentSlotsDistributor\",{attrs:{\"slot-key\":_.$parent.slotKey}},[r(\"h1\",{attrs:{id:\"事务\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#事务\"}},[_._v(\"#\")]),_._v(\" 事务\")]),_._v(\" \"),r(\"h2\",{attrs:{id:\"_1-什么是事务\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_1-什么是事务\"}},[_._v(\"#\")]),_._v(\" 1. 什么是事务\")]),_._v(\" \"),r(\"p\",[r(\"strong\",[_._v(\"事务就是逻辑上的一组操作，要么都执行，要么都不执行\")])]),_._v(\" \"),r(\"h3\",{attrs:{id:\"_1-1-案例\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_1-1-案例\"}},[_._v(\"#\")]),_._v(\" 1.1 案例\")]),_._v(\" \"),r(\"p\",[_._v(\"事务最经典例子转账：假设小明要给小红转账1000元，这个转账会涉及到两个关键操作\")]),_._v(\" \"),r(\"ul\",[r(\"li\",[_._v(\"将小明的余额减少1000元\")]),_._v(\" \"),r(\"li\",[_._v(\"将小红的余额增加1000元\")])]),_._v(\" \"),r(\"p\",[_._v(\"万一在这两个操作之间突然出现错误比如银行系统奔溃，导致小明余额减少而小红的余额没有增加，这就不对了。\\n事务就是保证这两个关键操作要么都成功，要么都失败\")]),_._v(\" \"),r(\"h2\",{attrs:{id:\"_2-事务的四大特性-acid\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_2-事务的四大特性-acid\"}},[_._v(\"#\")]),_._v(\" 2. 事务的四大特性（ACID）\")]),_._v(\" \"),r(\"p\",[r(\"img\",{attrs:{src:t(534),alt:\"image-20190911000830006\"}})]),_._v(\" \"),r(\"ol\",[r(\"li\",[r(\"p\",[r(\"strong\",[_._v(\"原子性（Atomicity）\")]),_._v(\":\")]),_._v(\" \"),r(\"p\",[_._v(\"事务是\"),r(\"strong\",[_._v(\"最小的执行单位，不予许分割\")]),_._v(\"，事务的原子性保证动作么全部完成，要么完全不起作用\")])]),_._v(\" \"),r(\"li\",[r(\"p\",[r(\"strong\",[_._v(\"一致性（Consistency）\")]),_._v(\":\")]),_._v(\" \"),r(\"p\",[_._v(\"执行事务前后，数据保持一致，\"),r(\"strong\",[_._v(\"多个事务对同一个数据读取结果是相同的\")])])]),_._v(\" \"),r(\"li\",[r(\"p\",[r(\"strong\",[_._v(\"隔离性（Isolation）\")]),_._v(\"：\")]),_._v(\" \"),r(\"p\",[_._v(\"并发访问数据库时，一个用户的事务不被其他事务所干扰，\"),r(\"strong\",[_._v(\"各并发事务之间数据库是独立的\")])])]),_._v(\" \"),r(\"li\",[r(\"p\",[r(\"strong\",[_._v(\"持久性（Durability）\")])]),_._v(\" \"),r(\"p\",[_._v(\"一个事务被提交之后，它\"),r(\"strong\",[_._v(\"对数据库中数据的改变是持久的\")]),_._v(\"，即使数据库发生故障也不应该对其有任何影响\")])])]),_._v(\" \"),r(\"h3\",{attrs:{id:\"_2-1-数据库是如何保证acid的\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_2-1-数据库是如何保证acid的\"}},[_._v(\"#\")]),_._v(\" 2.1 数据库是如何保证ACID的\")]),_._v(\" \"),r(\"ul\",[r(\"li\",[r(\"p\",[_._v(\"四个特性，最重要的就是一致性。而\"),r(\"strong\",[_._v(\"一致性\")]),_._v(\"由原子性、隔离性、持久性来保证\")])]),_._v(\" \"),r(\"li\",[r(\"p\",[_._v(\"原子性由Undo log保证：\")]),_._v(\" \"),r(\"p\",[_._v(\"Undo Log 会保存每次变更之前的记录，从而在发生错误时进行回滚\")])]),_._v(\" \"),r(\"li\",[r(\"p\",[_._v(\"隔离性由MVVC和Lock保证\")])]),_._v(\" \"),r(\"li\",[r(\"p\",[_._v(\"持久性有Redo Log保证\")]),_._v(\" \"),r(\"p\",[_._v(\"每次真正修改数据之前，都会将记录写到Redo Log中，只有redo log 写入成功，才会真正写入到B+tree中。如果提交之前断电，就可以通过Redo log恢复记录\")])])]),_._v(\" \"),r(\"h2\",{attrs:{id:\"_3-并发事务带来哪些问题\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_3-并发事务带来哪些问题\"}},[_._v(\"#\")]),_._v(\" 3. 并发事务带来哪些问题\")]),_._v(\" \"),r(\"p\",[_._v(\"在典型的应用程序中，多个事务并发运行，经常会操作相同的数据来完成各自的任务（\"),r(\"strong\",[_._v(\"多个用户对同一数据进行操作\")]),_._v(\"）。\")]),_._v(\" \"),r(\"p\",[_._v(\"并发虽然是必须的，但是可能会导致以下问题\")]),_._v(\" \"),r(\"ul\",[r(\"li\",[r(\"p\",[r(\"strong\",[_._v(\"脏读（Dirty read）\")])]),_._v(\" \"),r(\"ul\",[r(\"li\",[_._v(\"当一个事务正在访问数据并且对数据进行了修改，\"),r(\"strong\",[_._v(\"这种修改还没有提交到数据库中\")])]),_._v(\" \"),r(\"li\",[_._v(\"这时另外一个事务也访问了这个数据，然后\"),r(\"strong\",[_._v(\"使用了这个数据\")])]),_._v(\" \"),r(\"li\",[_._v(\"因为这个数据是还没有提交的数据，那么另外一个事务读到这个数据是“脏数据”，\"),r(\"strong\",[_._v(\"依据“脏数据”\"),r(\"strong\",[_._v(\"所做的\")]),_._v(\"操作可能是不正确的\")])])])]),_._v(\" \"),r(\"li\",[r(\"p\",[r(\"strong\",[_._v(\"丢失修改（Lost to modify）\")])]),_._v(\" \"),r(\"ul\",[r(\"li\",[r(\"p\",[_._v(\"在\"),r(\"strong\",[_._v(\"一个事务读取\")]),_._v(\"一个数据时，另外一个事务\"),r(\"strong\",[_._v(\"也访问了该数据\")])])]),_._v(\" \"),r(\"li\",[r(\"p\",[_._v(\"那么在\"),r(\"strong\",[_._v(\"第一个事务中修改\")]),_._v(\"了数据数据后，\"),r(\"strong\",[_._v(\"第二个事务也修改\")]),_._v(\"了这个数据\")])]),_._v(\" \"),r(\"li\",[r(\"p\",[_._v(\"这样\"),r(\"strong\",[_._v(\"第一个事务内的修改就被丢失\")]),_._v(\"，因此称为丢失修改\")]),_._v(\" \"),r(\"p\",[_._v(\"例如：事务1 读取某表中的数据A=20，事务2也读取了A=20，事务1修改A=A-1,事务2也修改了A-1，最终结果A=19，事务1的修改被丢失\")])])])]),_._v(\" \"),r(\"li\",[r(\"p\",[r(\"strong\",[_._v(\"不可重复读（Unrepeatableread）\")])]),_._v(\" \"),r(\"ul\",[r(\"li\",[r(\"p\",[_._v(\"指在一个事务内\"),r(\"strong\",[_._v(\"多次读同一数据\")]),_._v(\"，在这个事务还没有结束时，\"),r(\"strong\",[_._v(\"另一个事务也访问该数据\")])])]),_._v(\" \"),r(\"li\",[r(\"p\",[_._v(\"那么，在第一个事务中的两次读数据之间，\"),r(\"strong\",[_._v(\"由于第二个事务的修改\")]),_._v(\"导致\"),r(\"strong\",[_._v(\"第一个事务两次读取\")]),_._v(\"的数据可能不太一样\")]),_._v(\" \"),r(\"p\",[_._v(\"这样就发生了在一个事务内两次读到的数据是不一样的情况，因此称为不可重读读\")])])])]),_._v(\" \"),r(\"li\",[r(\"p\",[r(\"strong\",[_._v(\"幻读（Phantom read）\")])]),_._v(\" \"),r(\"ul\",[r(\"li\",[_._v(\"幻读与不可重复读类似。\")]),_._v(\" \"),r(\"li\",[_._v(\"他发生在\"),r(\"strong\",[_._v(\"一个事务（T1）读取了几行数据\")]),_._v(\"，接着另一个并发\"),r(\"strong\",[_._v(\"事务（T2）插入了一些数据\")]),_._v(\"时\")]),_._v(\" \"),r(\"li\",[_._v(\"在随后的查询中，第一个事务（T1）就会发现\"),r(\"strong\",[_._v(\"多了一些根本不存在的记录\")])])]),_._v(\" \"),r(\"p\",[_._v(\"就好像发生了幻觉一样，所以称为幻读\")])])]),_._v(\" \"),r(\"h3\",{attrs:{id:\"_3-1-不可重复读和幻读区别\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_3-1-不可重复读和幻读区别\"}},[_._v(\"#\")]),_._v(\" 3.1 不可重复读和幻读区别\")]),_._v(\" \"),r(\"ul\",[r(\"li\",[r(\"p\",[_._v(\"不可重复读的\"),r(\"strong\",[_._v(\"重点是修改\")])]),_._v(\" \"),r(\"p\",[_._v(\"比如：多次读取一条记录，发现其中某些列的值被修改\")])]),_._v(\" \"),r(\"li\",[r(\"p\",[_._v(\"幻读的\"),r(\"strong\",[_._v(\"重点在与新增或者删除\")])]),_._v(\" \"),r(\"p\",[_._v(\"比如：多次读取一条记录，发现记录增多或减少了\")])])]),_._v(\" \"),r(\"h2\",{attrs:{id:\"_4-事务隔离级别有哪些\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_4-事务隔离级别有哪些\"}},[_._v(\"#\")]),_._v(\" 4. 事务隔离级别有哪些\")]),_._v(\" \"),r(\"p\",[_._v(\"SQL 标准定义了四个隔离级别\")]),_._v(\" \"),r(\"ul\",[r(\"li\",[r(\"p\",[r(\"strong\",[_._v(\"READ-UNCOMMITTED(读取未提交)：\")])]),_._v(\" \"),r(\"p\",[_._v(\"最低的隔离级别，允许读取尚未提交的数据变更，\"),r(\"strong\",[_._v(\"可能会导致脏读，幻读，或不可重复读\")])])]),_._v(\" \"),r(\"li\",[r(\"p\",[r(\"strong\",[_._v(\"READ-COMMITTED(读取已提交)：\")])]),_._v(\" \"),r(\"p\",[_._v(\"允许读取并发事务已经提交的数据，\"),r(\"strong\",[_._v(\"可以阻止脏读，但是幻读或者不可重复读仍然有可能发生\")])])]),_._v(\" \"),r(\"li\",[r(\"p\",[r(\"strong\",[_._v(\"REPEATABLE-READ(可重复读)：\")])]),_._v(\" \"),r(\"p\",[_._v(\"对同一个字段的多次读取结果结果都是一致的，除非数据是被本身事务自己所修改，\"),r(\"strong\",[_._v(\"可以阻止脏读和不可重复读，但幻读仍有可能发生\")])])]),_._v(\" \"),r(\"li\",[r(\"p\",[r(\"strong\",[_._v(\"SERIALIZABLE(可串行化)：\")])]),_._v(\" \"),r(\"p\",[_._v(\"最高的隔离级别，完全服从ACID的隔离级别。\"),r(\"strong\",[_._v(\"所有的事务依次逐个执行\")]),_._v(\"，这样事务之间不可能产生干扰，也就是说，\"),r(\"strong\",[_._v(\"该级别可以防止脏读，不可重复读以及幻读\")])])])]),_._v(\" \"),r(\"p\",[_._v(\"​\")]),_._v(\" \"),r(\"table\",[r(\"thead\",[r(\"tr\",[r(\"th\",[_._v(\"隔离级别\")]),_._v(\" \"),r(\"th\",[_._v(\"脏读\")]),_._v(\" \"),r(\"th\",[_._v(\"不可重复读\")]),_._v(\" \"),r(\"th\",[_._v(\"幻影读\")])])]),_._v(\" \"),r(\"tbody\",[r(\"tr\",[r(\"td\",[_._v(\"READ-UNCOMMITTED\")]),_._v(\" \"),r(\"td\",[_._v(\"√\")]),_._v(\" \"),r(\"td\",[_._v(\"√\")]),_._v(\" \"),r(\"td\",[_._v(\"√\")])]),_._v(\" \"),r(\"tr\",[r(\"td\",[_._v(\"READ-COMMITTED\")]),_._v(\" \"),r(\"td\",[_._v(\"×\")]),_._v(\" \"),r(\"td\",[_._v(\"√\")]),_._v(\" \"),r(\"td\",[_._v(\"√\")])]),_._v(\" \"),r(\"tr\",[r(\"td\",[_._v(\"REPEATABLE-READ\")]),_._v(\" \"),r(\"td\",[_._v(\"×\")]),_._v(\" \"),r(\"td\",[_._v(\"×\")]),_._v(\" \"),r(\"td\",[_._v(\"√\")])]),_._v(\" \"),r(\"tr\",[r(\"td\",[_._v(\"SERIALIZABLE\")]),_._v(\" \"),r(\"td\",[_._v(\"×\")]),_._v(\" \"),r(\"td\",[_._v(\"×\")]),_._v(\" \"),r(\"td\",[_._v(\"×\")])])])]),_._v(\" \"),r(\"h2\",{attrs:{id:\"_5-mysql-innodb-的隔离级别\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_5-mysql-innodb-的隔离级别\"}},[_._v(\"#\")]),_._v(\" 5. MySQL innoDB 的隔离级别\")]),_._v(\" \"),r(\"p\",[_._v(\"MySQL innoDB 存储引擎的默认支持的隔离级别是\"),r(\"strong\",[_._v(\"REPEATABLE-READ（可重复读）\")])]),_._v(\" \"),r(\"p\",[_._v(\"可以通过\"),r(\"code\",[_._v(\"SELECT @@tx_isolation;\")]),_._v(\"命令来查看\")]),_._v(\" \"),r(\"div\",{staticClass:\"language- extra-class\"},[r(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[r(\"code\",[_._v(\"mysql> SELECT @@tx_isolation;\\n+-----------------+\\n| @@tx_isolation  |\\n+-----------------+\\n| REPEATABLE-READ |\\n+-----------------+\\n1 row in set, 1 warning (0.00 sec)\\n\")])])]),r(\"h3\",{attrs:{id:\"_5-1-innodb-的-repeatable-read为什么可以避免幻读\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_5-1-innodb-的-repeatable-read为什么可以避免幻读\"}},[_._v(\"#\")]),_._v(\" 5.1 InnoDB 的 REPEATABLE-READ为什么可以避免幻读\")]),_._v(\" \"),r(\"ul\",[r(\"li\",[r(\"p\",[r(\"strong\",[_._v(\"Next-key Lock锁算法\")]),_._v(\"。因此可以避免幻读的产生\")]),_._v(\" \"),r(\"ul\",[r(\"li\",[_._v(\"与SQL 标准不同的地方在于InnoDB 存储在 \"),r(\"strong\",[_._v(\"REPEATABLE-READ（可重读）\"),r(\"strong\",[_._v(\"事务隔离界别下使用的是\")]),_._v(\"Next-key Lock锁算法\")]),_._v(\"。因此可以\"),r(\"strong\",[_._v(\"避免幻读的产生\")])]),_._v(\" \"),r(\"li\",[_._v(\"这与其他数据库系统（如：SQL Server）是不同的，所以说InnoDB 存在引擎的默认支持的隔离级别是REPEATABLE-READ（可重读），已经可以完全保证事务的隔离性要求，既达到了SQL 标准的\"),r(\"strong\",[_._v(\"SERIALIZABLE(可串行化)\")]),_._v(\" 隔离级别\")]),_._v(\" \"),r(\"li\",[_._v(\"因为隔离级别越低，事务请求的锁越少，但是大部分数据库的隔离级别都是\"),r(\"strong\",[_._v(\"READ-COMMITTED(读取提交内容)\")]),_._v(\" ，但是你要知道的是InnoDB 存储引擎默认使用 \"),r(\"strong\",[_._v(\"REPEAaTABLE-READ（可重读）\")]),_._v(\" 并不会有任何性能损失。\")])])]),_._v(\" \"),r(\"li\",[r(\"p\",[_._v(\"InnoDB 存储引擎在 \"),r(\"strong\",[_._v(\"分布式事务\")]),_._v(\" 的情况下一般会用到 \"),r(\"strong\",[_._v(\"SERIALIZABLE(可串行化)\")]),_._v(\" 隔离级别。\")])])])])}),[],!1,null,null,null);v.default=s.exports},534:function(_,v,t){_.exports=t.p+\"assets/img/image-20190911000830006.f99c5ca4.png\"}}]);","extractedComments":[]}