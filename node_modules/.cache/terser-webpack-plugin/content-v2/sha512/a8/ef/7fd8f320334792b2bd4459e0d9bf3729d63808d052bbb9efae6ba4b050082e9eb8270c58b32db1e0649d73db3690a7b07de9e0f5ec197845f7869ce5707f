{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[187],{960:function(a,t,n){\"use strict\";n.r(t);var e=n(42),i=Object(e.a)({},(function(){var a=this,t=a.$createElement,n=a._self._c||t;return n(\"ContentSlotsDistributor\",{attrs:{\"slot-key\":a.$parent.slotKey}},[n(\"h1\",{attrs:{id:\"arraylist-的扩容机制\"}},[n(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#arraylist-的扩容机制\"}},[a._v(\"#\")]),a._v(\" ArrayList 的扩容机制\")]),a._v(\" \"),n(\"h2\",{attrs:{id:\"_1-如何实现扩容\"}},[n(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_1-如何实现扩容\"}},[a._v(\"#\")]),a._v(\" 1.如何实现扩容\")]),a._v(\" \"),n(\"p\",[a._v(\"底层主要是这三个私有方法配合实现\"),n(\"code\",[a._v(\"grow()\")]),a._v(\",\"),n(\"code\",[a._v(\"grow(int minCapacity)\")]),a._v(\",\"),n(\"code\",[a._v(\"newCapacity(int minCapacity)\")]),a._v(\"扩容。\"),n(\"strong\",[a._v(\"最终是调用了\"),n(\"code\",[a._v(\"Arrays.copyOf\")]),a._v(\"方法来进行扩充数组容量的\")]),a._v(\"。默认情况下，新的容量是\"),n(\"strong\",[a._v(\"原容量的1.5倍\")]),a._v(\"。\")]),a._v(\" \"),n(\"div\",{staticClass:\"language- extra-class\"},[n(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[n(\"code\",[a._v(\"// 扩容一个\\nprivate Object[] grow() {\\n\\treturn grow(size + 1);\\n}\\n\\n// 保证扩容到期望容量minCapacity及以上\\nprivate Object[] grow(int minCapacity) {\\n    return elementData = Arrays.copyOf(elementData,\\n                                       newCapacity(minCapacity));\\n}\\n\\n// 根据期望容量minCapacity计算实际需要扩容的容量\\nprivate int newCapacity(int minCapacity) {\\n    // overflow-conscious code\\n    int oldCapacity = elementData.length; // 得到旧容量\\n    int newCapacity = oldCapacity + (oldCapacity >> 1); // 设置新容量为旧容量的1.5倍\\n    if (newCapacity - minCapacity <= 0) { // 如果新容量仍然小于期望容量\\n        if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) // 如果是使用的默认容量\\n            return Math.max(DEFAULT_CAPACITY, minCapacity); // 取默认容量和期望容量较大值返回\\n        if (minCapacity < 0) // overflow // 检查期望容量是否越界（int 的范围）\\n            throw new OutOfMemoryError();\\n        return minCapacity; // 返回期望容量\\n    }\\n    // 如果新容量大于期望容量，判断一下新容量是否越界\\n    return (newCapacity - MAX_ARRAY_SIZE <= 0)\\n        ? newCapacity\\n        : hugeCapacity(minCapacity);\\n}\\n\\n\")])])]),n(\"h2\",{attrs:{id:\"_2-手动扩容\"}},[n(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_2-手动扩容\"}},[a._v(\"#\")]),a._v(\" 2. 手动扩容\")]),a._v(\" \"),n(\"p\",[a._v(\"grow方法主要用于实现自动扩容的，而用户也可以通过调用以下方法实现手动扩容：\")]),a._v(\" \"),n(\"div\",{staticClass:\"language- extra-class\"},[n(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[n(\"code\",[a._v(\"public void ensureCapacity(int minCapacity) {\\n    if (minCapacity > elementData.length\\n        && !(elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA\\n             && minCapacity <= DEFAULT_CAPACITY)) {\\n        modCount++;\\n        grow(minCapacity);\\n    }\\n}\\n\\n\")])])]),n(\"p\",[a._v(\"为什么需要手动扩容？试想一下，如果用户已经知道即将存入大量的元素，比如目前有20个元素，即将存入2000个。那这个时候使用自动扩容就会扩容多次。而手动扩容可以一次性扩容到2000，可以提高性能。\")])])}),[],!1,null,null,null);t.default=i.exports}}]);","extractedComments":[]}