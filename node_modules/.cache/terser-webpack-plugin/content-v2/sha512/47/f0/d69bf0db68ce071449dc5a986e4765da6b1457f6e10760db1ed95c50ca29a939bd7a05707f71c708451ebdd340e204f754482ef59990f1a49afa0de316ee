{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[309],{1313:function(t,i,n){\"use strict\";n.r(i);var a=n(42),r=Object(a.a)({},(function(){var t=this,i=t.$createElement,n=t._self._c||i;return n(\"ContentSlotsDistributor\",{attrs:{\"slot-key\":t.$parent.slotKey}},[n(\"h1\",{attrs:{id:\"zinkin基础\"}},[n(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#zinkin基础\"}},[t._v(\"#\")]),t._v(\" ZinKin基础\")]),t._v(\" \"),n(\"h2\",{attrs:{id:\"_1-是什么\"}},[n(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_1-是什么\"}},[t._v(\"#\")]),t._v(\" 1. 是什么？\")]),t._v(\" \"),n(\"p\",[t._v(\"Zipkin 分布式跟踪系统\")]),t._v(\" \"),n(\"p\",[t._v(\"可以帮助收集时间数据，解决在microservice 架构下的延迟问题\")]),t._v(\" \"),n(\"p\",[t._v(\"管理这些数据的收集和查找\")]),t._v(\" \"),n(\"blockquote\",[n(\"p\",[t._v(\"每个应用程序向Zipkin 报告定时数据，Zipkin UI 呈现了一个依赖图表来展示多少跟踪请求经过了每个应用程序；如果想解决延迟问题，可以过滤或者排序所有的跟踪请求，并且可以查看跟踪请求占总跟踪时间的百分比\")])]),t._v(\" \"),n(\"h2\",{attrs:{id:\"_2-为什么使用zipkin\"}},[n(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_2-为什么使用zipkin\"}},[t._v(\"#\")]),t._v(\" 2. 为什么使用Zipkin\")]),t._v(\" \"),n(\"p\",[t._v(\"随着业务越来越复杂，系统也随之进行各种拆分。特别是随着微服务架构和容器技术的兴起，看似简单的一个应用，后台可能有几十个甚至几百个服务在支撑；一个前端的请求可能需要多次的服务调用最后才能完成；当请求变慢或者不可用时，我们无法得知是哪个后台服务引起的，这时就需要解决如何快速定位服务故障点，Zipkin 分布式跟踪系统就能很好的解决这样的问题。\")])])}),[],!1,null,null,null);i.default=r.exports}}]);","extractedComments":[]}