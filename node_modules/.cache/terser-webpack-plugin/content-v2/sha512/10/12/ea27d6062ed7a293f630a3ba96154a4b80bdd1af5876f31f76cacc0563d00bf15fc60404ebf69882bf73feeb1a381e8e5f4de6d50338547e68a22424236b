{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[30],{1059:function(a,t,e){\"use strict\";e.r(t);var n=e(42),s=Object(n.a)({},(function(){var a=this,t=a.$createElement,n=a._self._c||t;return n(\"ContentSlotsDistributor\",{attrs:{\"slot-key\":a.$parent.slotKey}},[n(\"h1\",{attrs:{id:\"如何发现、预防、解决死锁\"}},[n(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#如何发现、预防、解决死锁\"}},[a._v(\"#\")]),a._v(\" 如何发现、预防、解决死锁\")]),a._v(\" \"),n(\"h2\",{attrs:{id:\"_1-死锁的定义\"}},[n(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_1-死锁的定义\"}},[a._v(\"#\")]),a._v(\" 1. 死锁的定义\")]),a._v(\" \"),n(\"p\",[a._v(\"“死锁是指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。”\")]),a._v(\" \"),n(\"p\",[a._v(\"竞争的资源可以是：锁、网络连接、通知事件，磁盘、带宽，以及一切可以被称作“资源”的东西。\")]),a._v(\" \"),n(\"h2\",{attrs:{id:\"_2-举例\"}},[n(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_2-举例\"}},[a._v(\"#\")]),a._v(\" 2. 举例\")]),a._v(\" \"),n(\"p\",[a._v(\"如果此时有一个线程A，按照先锁a再获得锁b的顺序获得锁，而在此时又有一个线程B，按照先锁b再锁a的顺序获得锁\")]),a._v(\" \"),n(\"p\",[n(\"img\",{attrs:{src:e(453),alt:\"image-20200311231729573\"}})]),a._v(\" \"),n(\"p\",[a._v(\"我们可以用一段代码来表示：\")]),a._v(\" \"),n(\"div\",{staticClass:\"language- extra-class\"},[n(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[n(\"code\",[a._v('public static void main(String[] args) {\\n    final Object a = new Object();\\n    final Object b = new Object();\\n    Thread threadA = new Thread(new Runnable() {\\n        public void run() {\\n            synchronized (a) {\\n                try {\\n                    System.out.println(\"now i in threadA-locka\");\\n                    Thread.sleep(1000l);\\n                    synchronized (b) {\\n                        System.out.println(\"now i in threadA-lockb\");\\n                    }\\n                } catch (Exception e) {\\n                    // ignore\\n                }\\n            }\\n        }\\n    });\\n\\n    Thread threadB = new Thread(new Runnable() {\\n        public void run() {\\n            synchronized (b) {\\n                try {\\n                    System.out.println(\"now i in threadB-lockb\");\\n                    Thread.sleep(1000l);\\n                    synchronized (a) {\\n                        System.out.println(\"now i in threadB-locka\");\\n                    }\\n                } catch (Exception e) {\\n                    // ignore\\n                }\\n            }\\n        }\\n    });\\n\\n    threadA.start();\\n    threadB.start();\\n}\\n\\n')])])]),n(\"p\",[a._v(\"我们可以看到执行结果如下：\")]),a._v(\" \"),n(\"p\",[n(\"img\",{attrs:{src:e(454),alt:\"image-20200311232054845\"}})]),a._v(\" \"),n(\"p\",[a._v(\"很明显，程序执行停滞了\")]),a._v(\" \"),n(\"h2\",{attrs:{id:\"_2-死锁检测\"}},[n(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_2-死锁检测\"}},[a._v(\"#\")]),a._v(\" 2. 死锁检测\")]),a._v(\" \"),n(\"p\",[a._v(\"主要介绍两种死锁检查工具\")]),a._v(\" \"),n(\"h2\",{attrs:{id:\"_2-1-jstack命令\"}},[n(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_2-1-jstack命令\"}},[a._v(\"#\")]),a._v(\" 2.1 Jstack命令\")]),a._v(\" \"),n(\"p\",[a._v(\"Jstack 是java 虚拟机自带的一种堆栈跟踪工具。jstack 用于\"),n(\"strong\",[a._v(\"打印\")]),a._v(\"出给定的java 进程ID或core file 或远程调试服务的\"),n(\"strong\",[a._v(\"java堆栈信息\")]),a._v(\"。Jstack工具可以用于生成Java虚拟机当前时刻的线程快照，\"),n(\"strong\",[a._v(\"线程快照\")]),a._v(\"是当前java虚拟机内每一条线程\"),n(\"strong\",[a._v(\"正在执行\")]),a._v(\"的\"),n(\"strong\",[a._v(\"方法堆栈\")]),a._v(\"的集合，生成线程快照的主要目的是定位线程出现长时间停顿原因，如\"),n(\"code\",[a._v(\"线程间死锁\")]),a._v(\"、\"),n(\"code\",[a._v(\"死循环\")]),a._v(\"、\"),n(\"code\",[a._v(\"请求外部资源导致的长时间等待\")]),a._v(\"等。线程出现停顿的时候通过jstack来查看各个线程的调用堆栈，就可以知道没有相应的线程到底在后台做了什么事情，或者等待什么资源\")]),a._v(\" \"),n(\"p\",[a._v(\"首先，我们通过jps确定当前执行任务的进程号:\")]),a._v(\" \"),n(\"div\",{staticClass:\"language- extra-class\"},[n(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[n(\"code\",[a._v(\"jonny@~$ jps\\n597\\n1370 JConsole\\n1362 AppMain\\n1421 Jps\\n1361 Launcher\\n\")])])]),n(\"p\",[a._v(\"可以确定任务进程号1362，然后执行jstack命令查看当前进程堆栈信息：\")]),a._v(\" \"),n(\"div\",{staticClass:\"language- extra-class\"},[n(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[n(\"code\",[a._v('jonny@~$ jstack -F 1362\\nAttaching to process ID 1362, please wait...\\nDebugger attached successfully.\\nServer compiler detected.\\nJVM version is 23.21-b01\\nDeadlock Detection:\\n\\nFound one Java-level deadlock:\\n=============================\\n\\n\"Thread-1\":\\n  waiting to lock Monitor@0x00007fea1900f6b8 (Object@0x00000007efa684c8, a java/lang/Object),\\n  which is held by \"Thread-0\"\\n\"Thread-0\":\\n  waiting to lock Monitor@0x00007fea1900ceb0 (Object@0x00000007efa684d8, a java/lang/Object),\\n  which is held by \"Thread-1\"\\n\\nFound a total of 1 deadlock.\\n\\n')])])]),n(\"p\",[a._v(\"可以看到，进程的确存在死锁，两个线程分别在等待对方持有的Object对象\")]),a._v(\" \"),n(\"h3\",{attrs:{id:\"_2-2-jconsole-工具\"}},[n(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_2-2-jconsole-工具\"}},[a._v(\"#\")]),a._v(\" 2.2 JConsole 工具\")]),a._v(\" \"),n(\"p\",[a._v(\"Jconsole 是 Jdk自带的监控工具，在Jdk/bin 目录下可以找到，他用户连接正在运行的本地或者远程的JVM，对运行在Java 应用程序的资源消耗和性能进行监控，并画出大量的图表，提供强大的可视化界面。而且本身占用的服务器内存很小\")]),a._v(\" \"),n(\"p\",[a._v(\"我们在命令行中敲入jconsole命令，会自动弹出以下对话框，选择进程1362，并点击“\"),n(\"strong\",[a._v(\"链接\")]),a._v(\"”\")]),a._v(\" \"),n(\"p\",[n(\"img\",{attrs:{src:e(455),alt:\"image-20200311234432625\"}})]),a._v(\" \"),n(\"p\",[a._v(\"进入锁检查的进程后，选择“线程”选项卡，并点击“检查死锁”\")]),a._v(\" \"),n(\"p\",[n(\"img\",{attrs:{src:e(456),alt:\"image-20200311234702867\"}})]),a._v(\" \"),n(\"p\",[a._v(\"我们可以看到\")]),a._v(\" \"),n(\"p\",[n(\"img\",{attrs:{src:e(457),alt:\"image-20200311234651568\"}})]),a._v(\" \"),n(\"p\",[a._v(\"可以看到进程中存在死锁\")]),a._v(\" \"),n(\"h2\",{attrs:{id:\"_2-预防与解决死锁\"}},[n(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_2-预防与解决死锁\"}},[a._v(\"#\")]),a._v(\" 2. 预防与解决死锁\")]),a._v(\" \"),n(\"p\",[a._v(\"破坏死锁产生的四个必要条件\")]),a._v(\" \"),n(\"h3\",{attrs:{id:\"_2-1-破坏互斥条件\"}},[n(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_2-1-破坏互斥条件\"}},[a._v(\"#\")]),a._v(\" 2.1 破坏互斥条件\")]),a._v(\" \"),n(\"p\",[a._v(\"这个条件我们没有办法破坏，因为我们用锁本来就是想让他们互斥的（临界资源需要互斥访问）\")]),a._v(\" \"),n(\"h3\",{attrs:{id:\"_2-2-破坏请求与保持条件\"}},[n(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_2-2-破坏请求与保持条件\"}},[a._v(\"#\")]),a._v(\" 2.2 破坏请求与保持条件\")]),a._v(\" \"),n(\"p\",[a._v(\"一次性申请所有的资源\")]),a._v(\" \"),n(\"h3\",{attrs:{id:\"_2-3-破坏不可剥夺条件\"}},[n(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_2-3-破坏不可剥夺条件\"}},[a._v(\"#\")]),a._v(\" 2.3 破坏不可剥夺条件\")]),a._v(\" \"),n(\"p\",[a._v(\"占用部分资源的线程进一步申请其他资源时，如果申请不到，可以\"),n(\"strong\",[a._v(\"主动释放他占有的资源\")])]),a._v(\" \"),n(\"h3\",{attrs:{id:\"_2-4-破坏循环等待条件\"}},[n(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_2-4-破坏循环等待条件\"}},[a._v(\"#\")]),a._v(\" 2.4 破坏循环等待条件\")]),a._v(\" \"),n(\"p\",[a._v(\"靠按顺序申请资源来预防，按某一顺序申请资源，释放资源则反序释放。破坏循环等待条件\")])])}),[],!1,null,null,null);t.default=s.exports},453:function(a,t,e){a.exports=e.p+\"assets/img/image-20200311231729573.fee5b228.png\"},454:function(a,t,e){a.exports=e.p+\"assets/img/image-20200311232054845.010d43b3.png\"},455:function(a,t,e){a.exports=e.p+\"assets/img/image-20200311234432625.8041c449.png\"},456:function(a,t,e){a.exports=e.p+\"assets/img/image-20200311234702867.bef1f5cf.png\"},457:function(a,t,e){a.exports=e.p+\"assets/img/image-20200311234651568.37e2ac0b.png\"}}]);","extractedComments":[]}