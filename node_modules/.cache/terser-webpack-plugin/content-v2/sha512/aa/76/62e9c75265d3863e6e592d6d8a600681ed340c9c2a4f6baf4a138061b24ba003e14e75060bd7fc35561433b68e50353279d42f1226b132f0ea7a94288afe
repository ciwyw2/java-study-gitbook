{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[366],{1131:function(t,e,n){\"use strict\";n.r(e);var a=n(42),r=Object(a.a)({},(function(){var t=this,e=t.$createElement,n=t._self._c||e;return n(\"ContentSlotsDistributor\",{attrs:{\"slot-key\":t.$parent.slotKey}},[n(\"h1\",{attrs:{id:\"springboot-自动配置之-enable-与-import注解\"}},[n(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#springboot-自动配置之-enable-与-import注解\"}},[t._v(\"#\")]),t._v(\" SpringBoot 自动配置之@Enable*与@Import注解\")]),t._v(\" \"),n(\"p\",[t._v(\"SpringBoot 的自动配置非常强大，我们经常使用的\"),n(\"code\",[t._v(\"@Enable*\")]),t._v(\"注解来开启对某方面的支持，那么\"),n(\"code\",[t._v(\"@Enable*\")]),t._v(\" 注解的原理是什么？\")]),t._v(\" \"),n(\"h2\",{attrs:{id:\"_1-enable-注解与-import-注解之间的关系\"}},[n(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_1-enable-注解与-import-注解之间的关系\"}},[t._v(\"#\")]),t._v(\" 1. @Enable* 注解与 @Import 注解之间的关系\")]),t._v(\" \"),n(\"p\",[t._v(\"@Enable*举例\")]),t._v(\" \"),n(\"ul\",[n(\"li\",[t._v(\"@EnableScheduling 开启计划任务的支持\")]),t._v(\" \"),n(\"li\",[t._v(\"@EnableAsync 开启异步方法的支持\")])]),t._v(\" \"),n(\"p\",[t._v(\"我们观察这些@Enable\"),n(\"em\",[t._v(\"源码可以看出，所有@Enable\")]),t._v(\" 注解都是有@Import的组合注解，@Enable* 自助开启的实现其实就是导入例如一些自动配置的bean\")]),t._v(\" \"),n(\"p\",[n(\"strong\",[t._v(\"@Import 注解的最主要功能就是导入额外的配置信息\")])]),t._v(\" \"),n(\"h2\",{attrs:{id:\"_2-import注解的用法\"}},[n(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_2-import注解的用法\"}},[t._v(\"#\")]),t._v(\" 2. @Import注解的用法\")]),t._v(\" \"),n(\"h3\",{attrs:{id:\"_2-1-方式一-直接导入配置类-configuration-类\"}},[n(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_2-1-方式一-直接导入配置类-configuration-类\"}},[t._v(\"#\")]),t._v(\" 2.1 方式一：直接导入配置类（@Configuration 类）\")]),t._v(\" \"),n(\"div\",{staticClass:\"language- extra-class\"},[n(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[n(\"code\",[t._v(\"@Target(ElementType.TYPE)\\n@Retention(RetentionPolicy.RUNTIME)\\n@Import(SchedulingConfiguration.class)\\n@Documented\\npublic @interface EnableScheduling {\\n\\n}\\n\")])])]),n(\"p\",[t._v(\"可以看到EnableScheduling 注解直接导入配置类 SchedulingConfiguration，这个类注解了@Configuration，且注册了一个scheduledAnnotationProcessor的Bean，SchedulingConfiguration的源码如下：\")]),t._v(\" \"),n(\"div\",{staticClass:\"language- extra-class\"},[n(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[n(\"code\",[t._v(\"@Configuration\\n@Role(BeanDefinition.ROLE_INFRASTRUCTURE)\\npublic class SchedulingConfiguration {\\n\\n\\t@Bean(name = TaskManagementConfigUtils.SCHEDULED_ANNOTATION_PROCESSOR_BEAN_NAME)\\n\\t@Role(BeanDefinition.ROLE_INFRASTRUCTURE)\\n\\tpublic ScheduledAnnotationBeanPostProcessor scheduledAnnotationProcessor() {\\n\\t\\treturn new ScheduledAnnotationBeanPostProcessor();\\n\\t}\\n\\n}\\n\\n\")])])]),n(\"h3\",{attrs:{id:\"_2-2-方式2-依据条件选择配置类-实现-importselector-接口\"}},[n(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_2-2-方式2-依据条件选择配置类-实现-importselector-接口\"}},[t._v(\"#\")]),t._v(\" 2.2 方式2：依据条件选择配置类（实现 ImportSelector 接口）\")]),t._v(\" \"),n(\"p\",[t._v(\"如果并不确定引入哪个配置类，需要根据@Import注解所标识的类或者另一个注解（通常是注解）里的定义信息选择配置类的话，用这种方式。\")]),t._v(\" \"),n(\"p\",[t._v(\"ImportSelector接口只有一个方法\")]),t._v(\" \"),n(\"div\",{staticClass:\"language- extra-class\"},[n(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[n(\"code\",[t._v(\"String[] selectImports(AnnotationMetadata importingClassMetadata);\\n\")])])]),n(\"p\",[t._v(\"AnnotationMetadata：用来获得当前配置类上的注解\")]),t._v(\" \"),n(\"p\",[t._v(\"例：\")]),t._v(\" \"),n(\"div\",{staticClass:\"language- extra-class\"},[n(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[n(\"code\",[t._v(\"@Target(ElementType.TYPE)\\n@Retention(RetentionPolicy.RUNTIME)\\n@Documented\\n@Import(AsyncConfigurationSelector.class)\\npublic @interface EnableAsync {\\n\\n\\tClass<? extends Annotation> annotation() default Annotation.class;\\n\\t\\n\\tboolean proxyTargetClass() default false;\\n\\n\\tAdviceMode mode() default AdviceMode.PROXY;\\n\\n\\tint order() default Ordered.LOWEST_PRECEDENCE;\\n\\n}\\n\\n\")])])]),n(\"p\",[t._v(\"AsyncConfigurationSelector继承AdviceModeImportSelector，AdviceModeImportSelector类实现ImportSelector接口 根据AdviceMode的不同来选择生明不同的Bean\")]),t._v(\" \"),n(\"div\",{staticClass:\"language- extra-class\"},[n(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[n(\"code\",[t._v('public class AsyncConfigurationSelector extends AdviceModeImportSelector<EnableAsync> {\\n\\n\\tprivate static final String ASYNC_EXECUTION_ASPECT_CONFIGURATION_CLASS_NAME =\\n\\t\\t\\t\"org.springframework.scheduling.aspectj.AspectJAsyncConfiguration\";\\n\\n\\t@Override\\n\\t@Nullable\\n\\tpublic String[] selectImports(AdviceMode adviceMode) {\\n\\t\\tswitch (adviceMode) {\\n\\t\\t\\tcase PROXY:\\n\\t\\t\\t\\treturn new String[] {ProxyAsyncConfiguration.class.getName()};\\n\\t\\t\\tcase ASPECTJ:\\n\\t\\t\\t\\treturn new String[] {ASYNC_EXECUTION_ASPECT_CONFIGURATION_CLASS_NAME};\\n\\t\\t\\tdefault:\\n\\t\\t\\t\\treturn null;\\n\\t\\t}\\n\\t}\\n\\n}\\n\\n\\n')])])]),n(\"h2\",{attrs:{id:\"_2-3-方式3-动态注册bean-实现-importbeandefinitionregistrar-接口\"}},[n(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_2-3-方式3-动态注册bean-实现-importbeandefinitionregistrar-接口\"}},[t._v(\"#\")]),t._v(\" 2.3 方式3：动态注册Bean（实现 ImportBeanDefinitionRegistrar 接口）\")]),t._v(\" \"),n(\"p\",[t._v(\"一般只要用户确切知道哪些Bean需要放入容器的话，自己可以通过spring 提供的注解来标识就可以了，比如@Component,@Service,@Repository,@Bean等。 如果是不确定的类，或者不是spring专用的，所以并不想用spring的注解进行侵入式标识，那么就可以通过@Import注解，实现ImportBeanDefinitionRegistrar接口来动态注册Bean。 比如：\")]),t._v(\" \"),n(\"div\",{staticClass:\"language- extra-class\"},[n(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[n(\"code\",[t._v(\"@Target(ElementType.TYPE)\\n@Retention(RetentionPolicy.RUNTIME)\\n@Documented\\n@Import(AspectJAutoProxyRegistrar.class)\\npublic @interface EnableAspectJAutoProxy {\\n\\n\\tboolean proxyTargetClass() default false;\\n\\t\\n\\tboolean exposeProxy() default false;\\n\\n}\\n复制代码\\n\")])])]),n(\"p\",[t._v(\"AspectJAutoProxyRegistrar实现了ImportBeanDefinitionRegistrar接口，ImportBeanDefinitionRegistrar的作用是在运行时自动添加Bean到已有的配置类，通过重写方法：\")]),t._v(\" \"),n(\"div\",{staticClass:\"language- extra-class\"},[n(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[n(\"code\",[t._v(\"public void registerBeanDefinitions(\\n\\t\\t\\tAnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry);\\n复制代码\\n\")])])]),n(\"ul\",[n(\"li\",[t._v(\"AnnotationMetadata  参数用来获得当前配置类上的注解\")]),t._v(\" \"),n(\"li\",[t._v(\"BeanDefinitionRegistry 参数用来注册Bean\")])]),t._v(\" \"),n(\"p\",[t._v(\"源码：\")]),t._v(\" \"),n(\"div\",{staticClass:\"language- extra-class\"},[n(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[n(\"code\",[t._v('@Override\\npublic void registerBeanDefinitions(\\n\\t\\tAnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) {\\n\\n\\tAopConfigUtils.registerAspectJAnnotationAutoProxyCreatorIfNecessary(registry);\\n\\n\\tAnnotationAttributes enableAspectJAutoProxy =\\n\\t\\t\\tAnnotationConfigUtils.attributesFor(importingClassMetadata, EnableAspectJAutoProxy.class);\\n\\tif (enableAspectJAutoProxy != null) {\\n\\t\\tif (enableAspectJAutoProxy.getBoolean(\"proxyTargetClass\")) {\\n\\t\\t\\tAopConfigUtils.forceAutoProxyCreatorToUseClassProxying(registry);\\n\\t\\t}\\n\\t\\tif (enableAspectJAutoProxy.getBoolean(\"exposeProxy\")) {\\n\\t\\t\\tAopConfigUtils.forceAutoProxyCreatorToExposeProxy(registry);\\n\\t\\t}\\n\\t}\\n}\\n复制代码\\n')])])]),n(\"h2\",{attrs:{id:\"参考文章\"}},[n(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#参考文章\"}},[t._v(\"#\")]),t._v(\" 参考文章\")]),t._v(\" \"),n(\"p\",[n(\"a\",{attrs:{href:\"https://juejin.im/post/5c761c096fb9a049b41d2299\",target:\"_blank\",rel:\"noopener noreferrer\"}},[t._v(\"Spring Boot 自动配置之@Enable* 与@Import注解\"),n(\"OutboundLink\")],1)])])}),[],!1,null,null,null);e.default=r.exports}}]);","extractedComments":[]}