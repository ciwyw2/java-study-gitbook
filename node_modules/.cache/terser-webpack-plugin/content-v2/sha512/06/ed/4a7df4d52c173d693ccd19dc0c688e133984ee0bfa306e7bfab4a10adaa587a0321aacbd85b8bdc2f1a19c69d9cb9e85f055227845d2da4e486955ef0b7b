{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[115],{380:function(e,t,n){e.exports=n.p+\"assets/img/image-20200316223656604.c15760e0.png\"},992:function(e,t,n){\"use strict\";n.r(t);var a=n(42),s=Object(a.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a(\"ContentSlotsDistributor\",{attrs:{\"slot-key\":e.$parent.slotKey}},[a(\"h1\",{attrs:{id:\"线程池的处理流程\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#线程池的处理流程\"}},[e._v(\"#\")]),e._v(\" 线程池的处理流程\")]),e._v(\" \"),a(\"h2\",{attrs:{id:\"_1-处理流程\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_1-处理流程\"}},[e._v(\"#\")]),e._v(\" 1. 处理流程\")]),e._v(\" \"),a(\"p\",[e._v(\"创建线程池需要使用ThreadPoolExecutor 类，他的构造函数参数如下\")]),e._v(\" \"),a(\"div\",{staticClass:\"language-java extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-java\"}},[a(\"code\",[a(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[e._v(\"public\")]),e._v(\" \"),a(\"span\",{pre:!0,attrs:{class:\"token class-name\"}},[e._v(\"ThreadPoolExecutor\")]),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[e._v(\"(\")]),a(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[e._v(\"int\")]),e._v(\" corePoolSize\"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[e._v(\",\")]),e._v(\"    \"),a(\"span\",{pre:!0,attrs:{class:\"token comment\"}},[e._v(\"//核心线程的数量\")]),e._v(\"\\n                          \"),a(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[e._v(\"int\")]),e._v(\" maximumPoolSize\"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[e._v(\",\")]),e._v(\"    \"),a(\"span\",{pre:!0,attrs:{class:\"token comment\"}},[e._v(\"//最大线程数量\")]),e._v(\"\\n                          \"),a(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[e._v(\"long\")]),e._v(\" keepAliveTime\"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[e._v(\",\")]),e._v(\"    \"),a(\"span\",{pre:!0,attrs:{class:\"token comment\"}},[e._v(\"//超出核心线程数量以外的线程空余存活时间\")]),e._v(\"\\n                          \"),a(\"span\",{pre:!0,attrs:{class:\"token class-name\"}},[e._v(\"TimeUnit\")]),e._v(\" unit\"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[e._v(\",\")]),e._v(\"    \"),a(\"span\",{pre:!0,attrs:{class:\"token comment\"}},[e._v(\"//存活时间的单位\")]),e._v(\"\\n                          \"),a(\"span\",{pre:!0,attrs:{class:\"token class-name\"}},[e._v(\"BlockingQueue\")]),a(\"span\",{pre:!0,attrs:{class:\"token generics\"}},[a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[e._v(\"<\")]),a(\"span\",{pre:!0,attrs:{class:\"token class-name\"}},[e._v(\"Runnable\")]),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[e._v(\">\")])]),e._v(\" workQueue\"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[e._v(\",\")]),e._v(\"    \"),a(\"span\",{pre:!0,attrs:{class:\"token comment\"}},[e._v(\"//保存待执行任务的队列\")]),e._v(\"\\n                          \"),a(\"span\",{pre:!0,attrs:{class:\"token class-name\"}},[e._v(\"ThreadFactory\")]),e._v(\" threadFactory\"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[e._v(\",\")]),e._v(\"    \"),a(\"span\",{pre:!0,attrs:{class:\"token comment\"}},[e._v(\"//创建新线程使用的工厂\")]),e._v(\"\\n                          \"),a(\"span\",{pre:!0,attrs:{class:\"token class-name\"}},[e._v(\"RejectedExecutionHandler\")]),e._v(\" handler \"),a(\"span\",{pre:!0,attrs:{class:\"token comment\"}},[e._v(\"// 当任务无法执行时的处理器\")]),e._v(\"\\n                          \"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[e._v(\")\")]),e._v(\" \"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[e._v(\"{\")]),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[e._v(\".\")]),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[e._v(\".\")]),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[e._v(\".\")]),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[e._v(\"}\")]),e._v(\"\\n\")])])]),a(\"p\",[e._v(\"参数介绍如注释所示，要了解这些参数左右着什么，就需要了解线程池具体的执行方法\"),a(\"code\",[e._v(\"ThreadPoolExecutor.execute\")]),e._v(\":\")]),e._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[e._v(\"public void execute(Runnable command) {\\n    if (command == null)\\n        throw new NullPointerException();\\n\\n    int c = ctl.get();\\n    //1.当前池中线程比核心数少，新建一个线程执行任务\\n    if (workerCountOf(c) < corePoolSize) {   \\n        if (addWorker(command, true))\\n            return;\\n        c = ctl.get();\\n    }\\n    //2.核心池已满，但任务队列未满，添加到队列中\\n    if (isRunning(c) && workQueue.offer(command)) {   \\n        int recheck = ctl.get();\\n        if (! isRunning(recheck) && remove(command))    //如果这时被关闭了，拒绝任务\\n            reject(command);\\n        else if (workerCountOf(recheck) == 0)    //如果之前的线程已被销毁完，新建一个线程\\n            addWorker(null, false);\\n    }\\n    //3.核心池已满，队列已满，试着创建一个新线程\\n    else if (!addWorker(command, false))\\n        reject(command);    //如果创建新线程失败了，说明线程池被关闭或者线程池完全满了，拒绝任务\\n}\\n\")])])]),a(\"p\",[e._v(\"流程图\")]),e._v(\" \"),a(\"p\",[a(\"img\",{attrs:{src:n(380),alt:\"image-20200316223656604\"}})]),e._v(\" \"),a(\"h2\",{attrs:{id:\"_2-构造器的作用\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_2-构造器的作用\"}},[e._v(\"#\")]),e._v(\" 2. 构造器的作用\")]),e._v(\" \"),a(\"ul\",[a(\"li\",[e._v(\"corePoolSize：核心线程池数量\\n\"),a(\"ul\",[a(\"li\",[e._v(\"在线程数少于核心数量时，有新任务进来就新建一个线程，即使有的线程没事干\")]),e._v(\" \"),a(\"li\",[e._v(\"等超出核心数量后，就不会新建线程了，空闲的线程就得去任务队列里取任务执行\")])])]),e._v(\" \"),a(\"li\",[e._v(\"maximumPoolSize: 最大线程数量\\n\"),a(\"ul\",[a(\"li\",[e._v(\"包含核心线程池数量+核心以为的数量\")]),e._v(\" \"),a(\"li\",[e._v(\"如果任务队列满了，并且池中线程数小于最大线程数，会再创建新的线程执行任务\")])])]),e._v(\" \"),a(\"li\",[a(\"code\",[e._v(\"keepAliveTime\")]),e._v(\"：核心池以外的线程存活时间，即没有任务的外包的存活时间\\n\"),a(\"ul\",[a(\"li\",[e._v(\"如果给线程池设置 \"),a(\"code\",[e._v(\"allowCoreThreadTimeOut(true)\")]),e._v(\"，则核心线程在空闲时头上也会响起死亡的倒计时\")]),e._v(\" \"),a(\"li\",[e._v(\"如果任务是多而容易执行的，可以调大这个参数，那样线程就可以在存活的时间里有更大可能接受新任务\")])])]),e._v(\" \"),a(\"li\",[a(\"code\",[e._v(\"workQueue\")]),e._v(\"：保存待执行任务的阻塞队列\\n\"),a(\"ul\",[a(\"li\",[e._v(\"ArrayBlockingQueue：基于数组、有界，按 FIFO（先进先出）原则对元素进行排序\")]),e._v(\" \"),a(\"li\",[e._v(\"LinkedBlockingQueue：基于链表，按FIFO （先进先出） 排序元素\\n\"),a(\"ul\",[a(\"li\",[e._v(\"吞吐量通常要高于 ArrayBlockingQueue\")]),e._v(\" \"),a(\"li\",[e._v(\"Executors.newFixedThreadPool() 使用了这个队列\")])])]),e._v(\" \"),a(\"li\",[e._v(\"SynchronousQueue：不存储元素的阻塞队列\\n\"),a(\"ul\",[a(\"li\",[e._v(\"每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态\")]),e._v(\" \"),a(\"li\",[e._v(\"吞吐量通常要高于 LinkedBlockingQueue\")]),e._v(\" \"),a(\"li\",[e._v(\"Executors.newCachedThreadPool使用了这个队列\")])])]),e._v(\" \"),a(\"li\",[e._v(\"PriorityBlockingQueue：具有优先级的、无限阻塞队列\")])])]),e._v(\" \"),a(\"li\",[a(\"code\",[e._v(\"threadFactory\")]),e._v(\"：每个线程创建的地方\\n\"),a(\"ul\",[a(\"li\",[e._v(\"可以给线程起个好听的名字，设置个优先级啥的\")])])]),e._v(\" \"),a(\"li\",[e._v(\"handler：饱和策略，大家都很忙，咋办呢，有四种策略\\n\"),a(\"ul\",[a(\"li\",[e._v(\"CallerRunsPolicy：只要线程池没关闭，就直接用调用者所在线程来运行任务\")]),e._v(\" \"),a(\"li\",[e._v(\"AbortPolicy：直接抛出 RejectedExecutionException 异\")]),e._v(\" \"),a(\"li\",[e._v(\"DiscardPolicy：悄悄把任务放生，不做了\")]),e._v(\" \"),a(\"li\",[e._v(\"DiscardOldestPolicy：把队列里待最久的那个任务扔了，然后再调用 execute() 试试看能行不\")]),e._v(\" \"),a(\"li\",[e._v(\"我们也可以实现自己的 RejectedExecutionHandler 接口自定义策略，比如如记录日志什么的\")])])])])])}),[],!1,null,null,null);t.default=s.exports}}]);","extractedComments":[]}