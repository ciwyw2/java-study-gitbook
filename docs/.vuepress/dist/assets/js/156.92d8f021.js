(window.webpackJsonp=window.webpackJsonp||[]).push([[156],{1122:function(_,v,t){"use strict";t.r(v);var i=t(42),r=Object(i.a)({},(function(){var _=this,v=_.$createElement,i=_._self._c||v;return i("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[i("h1",{attrs:{id:"springaop"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#springaop"}},[_._v("#")]),_._v(" SpringAOP")]),_._v(" "),i("h2",{attrs:{id:"_1-什么是aop"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#_1-什么是aop"}},[_._v("#")]),_._v(" 1. 什么是AOP")]),_._v(" "),i("p",[_._v("AOP既面向切面编程，官方定义")]),_._v(" "),i("blockquote",[i("p",[_._v("面向切面—— Spring提供了面向切面编程的丰富支持，允许通过分离应用的业务逻辑与系统级服务（例如审计（auditing）和事务（transaction）管理）进行内聚性的开发。应用对象只实现它们应该做的——完成业务逻辑——仅此而已。它们并不负责（甚至是意识）其它的系统级关注点，例如日志或事务支持。")])]),_._v(" "),i("p",[_._v("AOP可以分离系统的业务逻辑和系统服务(日志，安全等)，这个功能我想是不难明白（原理是使用了"),i("code",[_._v("代理模式")]),_._v("），但关键是为什么要将这两种进行分离呢？或者说这样做有什么好处？")]),_._v(" "),i("h3",{attrs:{id:"_1-1-面向切面的好处"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#_1-1-面向切面的好处"}},[_._v("#")]),_._v(" 1.1 面向切面的好处")]),_._v(" "),i("p",[_._v("在日常的软件开发中，拿日志来说，一个系统软件的开发都是必须进行日志记录的，不然万一系统出现什么bug，你都不知道是哪里出了问题。举个小栗子，当你开发一个登陆功能，你可能需要在用户登陆前后进行权限校验并将校验信息（"),i("code",[_._v("用户名")]),_._v(","),i("code",[_._v("密码")]),_._v(","),i("code",[_._v("请求登陆时间，ip地址")]),_._v("等）记录在日志文件中，当用户登录进来之后，当他访问某个其他功能时，也需要进行合法性校验。想想看，当系统非常地庞大，系统中专门进行权限验证的代码是非常多的，而且非常地散乱，我们就想能不能将这些权限校验、日志记录等非业务逻辑功能的部分独立拆分开，并且在系统运行时需要的地方（"),i("code",[_._v("连接点")]),_._v("）进行动态插入运行，不需要的时候就不理，因此AOP是能够解决这种状况的思想吧！")]),_._v(" "),i("p",[_._v("下图就很直观地展示这个过程：")]),_._v(" "),i("p",[i("img",{attrs:{src:t(826),alt:"image-20191011214543898"}})]),_._v(" "),i("h2",{attrs:{id:"_2-aop中的基本概念"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#_2-aop中的基本概念"}},[_._v("#")]),_._v(" 2. AOP中的基本概念")]),_._v(" "),i("ul",[i("li",[i("p",[_._v("通知（Adivce）")]),_._v(" "),i("p",[_._v("通知有5种类型:")]),_._v(" "),i("ul",[i("li",[i("code",[_._v("Before")]),_._v(" 在方法被调用之前调用")]),_._v(" "),i("li",[i("code",[_._v("After")]),_._v(" 在方法完成后调用通知，无论方法是否执行成功")]),_._v(" "),i("li",[i("code",[_._v("After-returning")]),_._v(" 在方法成功执行之后调用通知")]),_._v(" "),i("li",[i("code",[_._v("After-throwing")]),_._v(" 在方法抛出异常后调用通知")]),_._v(" "),i("li",[i("code",[_._v("Around")]),_._v(" 通知了好、包含了被通知的方法，在被通知的方法调用之前后调用之后执行自定义的行为")])])]),_._v(" "),i("li",[i("p",[_._v("切点（Pointcut）")]),_._v(" "),i("p",[_._v("切点在Spring AOP中确实是对应系统中的方法。但是这个方法是定义在切面中的方法，一般和通知一起使用，一起组成了切面。")])]),_._v(" "),i("li",[i("p",[_._v("连接点（Join point）")]),_._v(" "),i("p",[_._v("比如：方法调用、方法执行、字段设置/获取、异常处理执行、类初始化、甚至是 for 循环中的某个点")]),_._v(" "),i("p",[_._v("理论上, 程序执行过程中的任何时点都可以作为作为织入点, 而所有这些执行时点都是 Joint point")]),_._v(" "),i("p",[_._v("但 Spring AOP 目前仅支持方法执行 (method execution) 也可以这样理解，连接点就是你准备在系统中执行切点和切入通知的地方（一般是一个方法，一个字段）")])]),_._v(" "),i("li",[i("p",[_._v("切面（Aspect）")]),_._v(" "),i("p",[_._v("切面是切点和通知的集合，一般单独作为一个类。通知和切点共同定义了关于切面的全部内容，它是什么时候，在何时和何处完成功能。")])]),_._v(" "),i("li",[i("p",[_._v("引入（Introduction）")]),_._v(" "),i("p",[_._v("引用允许我们向现有的类添加新的方法或者属性")])]),_._v(" "),i("li",[i("p",[_._v("织入（Weaving）")]),_._v(" "),i("p",[_._v("组装方面来创建一个被通知对象。这可以在编译时完成（例如使用AspectJ编译器），也可以在运行时完成。Spring和其他纯Java AOP框架一样，在运行时完成织入。")])])]),_._v(" "),i("h2",{attrs:{id:"_3-spring-中对aop的支持"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#_3-spring-中对aop的支持"}},[_._v("#")]),_._v(" 3. Spring 中对AOP的支持")]),_._v(" "),i("p",[_._v("首先AOP思想的实现一般都是基于代理模式，在JAVA中一般采用JDK动态代理模式，但是我们都知道，JDK动态代理模式只能代理接口，如果要代理类那么就不行了")]),_._v(" "),i("p",[_._v("Spring AOP 同时支持 CGLIB、ASPECTJ、JDK动态代理，当你的真实对象有实现接口时，Spring AOP会默认采用JDK动态代理，否则采用cglib代理。")]),_._v(" "),i("ul",[i("li",[_._v("如果目标对象的实现类实现了接口，Spring AOP 将会采用 JDK 动态代理来生成 AOP 代理类；")]),_._v(" "),i("li",[_._v("如果目标对象的实现类没有实现接口，Spring AOP 将会采用 CGLIB 来生成 AOP 代理类——不过这个选择过程对开发者完全透明、开发者也无需关心。")])])])}),[],!1,null,null,null);v.default=r.exports},826:function(_,v,t){_.exports=t.p+"assets/img/image-20191011214543898.fc4f1a32.png"}}]);